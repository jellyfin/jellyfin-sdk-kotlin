// !!        WARNING
// !! DO NOT EDIT THIS FILE
//
// This file is generated by the openapi-generator module and is not meant for manual changes.
// Please read the README.md file in the openapi-generator module for additional information.
package org.jellyfin.sdk.api.operations

import io.ktor.utils.io.ByteReadChannel
import java.util.UUID
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import org.jellyfin.sdk.api.client.KtorClient
import org.jellyfin.sdk.api.client.Response
import org.jellyfin.sdk.model.api.FontFile
import org.jellyfin.sdk.model.api.RemoteSubtitleInfo
import org.jellyfin.sdk.model.api.UploadSubtitleDto

public class SubtitleApi(
	private val api: KtorClient
) {
	/**
	 * Gets a list of available fallback font files.
	 */
	public suspend fun getFallbackFontList(): Response<List<FontFile>> {
		val pathParameters = emptyMap<String, Any?>()
		val queryParameters = emptyMap<String, Any?>()
		val data = null
		val response = api.`get`<List<FontFile>>("/FallbackFont/Fonts", pathParameters, queryParameters,
				data)
		return response
	}

	/**
	 * Gets a fallback font file.
	 *
	 * @param name The name of the fallback font file to get.
	 */
	public suspend fun getFallbackFont(name: String): Response<ByteReadChannel> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["name"] = name
		val queryParameters = emptyMap<String, Any?>()
		val data = null
		val response = api.`get`<ByteReadChannel>("/FallbackFont/Fonts/{name}", pathParameters,
				queryParameters, data)
		return response
	}

	/**
	 * Gets a fallback font file.
	 *
	 * @param name The name of the fallback font file to get.
	 * @param includeCredentials Add the access token to the url to make an authenticated request.
	 */
	public fun getFallbackFontUrl(name: String, includeCredentials: Boolean = true): String {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["name"] = name
		val queryParameters = emptyMap<String, Any?>()
		return api.createUrl("/FallbackFont/Fonts/{name}", pathParameters, queryParameters,
				includeCredentials)
	}

	/**
	 * Search remote subtitles.
	 *
	 * @param itemId The item id.
	 * @param language The language of the subtitles.
	 * @param isPerfectMatch Optional. Only show subtitles which are a perfect match.
	 */
	public suspend fun searchRemoteSubtitles(
		itemId: UUID,
		language: String,
		isPerfectMatch: Boolean? = null
	): Response<List<RemoteSubtitleInfo>> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["language"] = language
		val queryParameters = mutableMapOf<String, Any?>()
		queryParameters["isPerfectMatch"] = isPerfectMatch
		val data = null
		val response =
				api.`get`<List<RemoteSubtitleInfo>>("/Items/{itemId}/RemoteSearch/Subtitles/{language}",
				pathParameters, queryParameters, data)
		return response
	}

	/**
	 * Downloads a remote subtitle.
	 *
	 * @param itemId The item id.
	 * @param subtitleId The subtitle id.
	 */
	public suspend fun downloadRemoteSubtitles(itemId: UUID, subtitleId: String): Response<Unit> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["subtitleId"] = subtitleId
		val queryParameters = emptyMap<String, Any?>()
		val data = null
		val response = api.post<Unit>("/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}",
				pathParameters, queryParameters, data)
		return response
	}

	/**
	 * Gets the remote subtitles.
	 *
	 * @param id The item id.
	 */
	public suspend fun getRemoteSubtitles(id: String): Response<String> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["id"] = id
		val queryParameters = emptyMap<String, Any?>()
		val data = null
		val response = api.`get`<String>("/Providers/Subtitles/Subtitles/{id}", pathParameters,
				queryParameters, data)
		return response
	}

	/**
	 * Gets subtitles in a specified format.
	 *
	 * @param itemId The item id.
	 * @param mediaSourceId The media source id.
	 * @param index The subtitle stream index.
	 * @param startPositionTicks Optional. The start position of the subtitle in ticks.
	 * @param format The format of the returned subtitle.
	 * @param endPositionTicks Optional. The end position of the subtitle in ticks.
	 * @param copyTimestamps Optional. Whether to copy the timestamps.
	 * @param addVttTimeMap Optional. Whether to add a VTT time map.
	 */
	public suspend fun getSubtitleWithTicks(
		itemId: UUID,
		mediaSourceId: String,
		index: Int,
		startPositionTicks: Long,
		format: String,
		endPositionTicks: Long? = null,
		copyTimestamps: Boolean = false,
		addVttTimeMap: Boolean = false
	): Response<String> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["mediaSourceId"] = mediaSourceId
		pathParameters["index"] = index
		pathParameters["startPositionTicks"] = startPositionTicks
		pathParameters["format"] = format
		val queryParameters = mutableMapOf<String, Any?>()
		queryParameters["endPositionTicks"] = endPositionTicks
		queryParameters["copyTimestamps"] = copyTimestamps
		queryParameters["addVttTimeMap"] = addVttTimeMap
		val data = null
		val response =
				api.`get`<String>("/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/{startPositionTicks}/Stream.{format}",
				pathParameters, queryParameters, data)
		return response
	}

	/**
	 * Gets subtitles in a specified format.
	 *
	 * @param itemId The item id.
	 * @param mediaSourceId The media source id.
	 * @param index The subtitle stream index.
	 * @param format The format of the returned subtitle.
	 * @param endPositionTicks Optional. The end position of the subtitle in ticks.
	 * @param copyTimestamps Optional. Whether to copy the timestamps.
	 * @param addVttTimeMap Optional. Whether to add a VTT time map.
	 * @param startPositionTicks Optional. The start position of the subtitle in ticks.
	 */
	public suspend fun getSubtitle(
		itemId: UUID,
		mediaSourceId: String,
		index: Int,
		format: String,
		endPositionTicks: Long? = null,
		copyTimestamps: Boolean = false,
		addVttTimeMap: Boolean = false,
		startPositionTicks: Long = 0
	): Response<String> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["mediaSourceId"] = mediaSourceId
		pathParameters["index"] = index
		pathParameters["format"] = format
		val queryParameters = mutableMapOf<String, Any?>()
		queryParameters["endPositionTicks"] = endPositionTicks
		queryParameters["copyTimestamps"] = copyTimestamps
		queryParameters["addVttTimeMap"] = addVttTimeMap
		queryParameters["startPositionTicks"] = startPositionTicks
		val data = null
		val response =
				api.`get`<String>("/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/Stream.{format}",
				pathParameters, queryParameters, data)
		return response
	}

	/**
	 * Gets an HLS subtitle playlist.
	 *
	 * @param itemId The item id.
	 * @param index The subtitle stream index.
	 * @param mediaSourceId The media source id.
	 * @param segmentLength The subtitle segment length.
	 */
	public suspend fun getSubtitlePlaylist(
		itemId: UUID,
		index: Int,
		mediaSourceId: String,
		segmentLength: Int
	): Response<ByteReadChannel> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["index"] = index
		pathParameters["mediaSourceId"] = mediaSourceId
		val queryParameters = mutableMapOf<String, Any?>()
		queryParameters["segmentLength"] = segmentLength
		val data = null
		val response =
				api.`get`<ByteReadChannel>("/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8",
				pathParameters, queryParameters, data)
		return response
	}

	/**
	 * Gets an HLS subtitle playlist.
	 *
	 * @param itemId The item id.
	 * @param index The subtitle stream index.
	 * @param mediaSourceId The media source id.
	 * @param segmentLength The subtitle segment length.
	 * @param includeCredentials Add the access token to the url to make an authenticated request.
	 */
	public fun getSubtitlePlaylistUrl(
		itemId: UUID,
		index: Int,
		mediaSourceId: String,
		segmentLength: Int,
		includeCredentials: Boolean = true
	): String {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["index"] = index
		pathParameters["mediaSourceId"] = mediaSourceId
		val queryParameters = mutableMapOf<String, Any?>()
		queryParameters["segmentLength"] = segmentLength
		return api.createUrl("/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8",
				pathParameters, queryParameters, includeCredentials)
	}

	/**
	 * Upload an external subtitle file.
	 *
	 * @param itemId The item the subtitle belongs to.
	 */
	public suspend fun uploadSubtitle(itemId: UUID, `data`: UploadSubtitleDto): Response<Unit> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		val queryParameters = emptyMap<String, Any?>()
		val response = api.post<Unit>("/Videos/{itemId}/Subtitles", pathParameters, queryParameters, data)
		return response
	}

	/**
	 * Deletes an external subtitle file.
	 *
	 * @param itemId The item id.
	 * @param index The index of the subtitle file.
	 */
	public suspend fun deleteSubtitle(itemId: UUID, index: Int): Response<Unit> {
		val pathParameters = mutableMapOf<String, Any?>()
		pathParameters["itemId"] = itemId
		pathParameters["index"] = index
		val queryParameters = emptyMap<String, Any?>()
		val data = null
		val response = api.delete<Unit>("/Videos/{itemId}/Subtitles/{index}", pathParameters,
				queryParameters, data)
		return response
	}
}
